APP1 Structure de données et complexité

* * *

# 06/01/2025 14:54 Après le tutorat d'ouverture

test matin

# 07/01/2025 10:45 Avant séminaire

## Lecture de Algorithms and Data Structures

### 2.1 Analyse d'algorithme

2 façon de faire une analyse d'efficacité:

1.  Regarder ==le montant de mémoire== utiliser afin d'accomplir une tâche
2.  ==Montant de temps== que ça prend pour accomplir une tâche  "Execution time or running time"

*Nous pouvons mesurer le temps d'exécution de la fonction ==**sum_of_n**== en effectuant une analyse comparative (**benchmarking**).*

Ceci est un example de comment évaluer le temps dans Python:

```Python
import time

def sum_of_n_2(n):
    start = time.time()

    the_sum = 0
    for i in range(1, n + 1):
        the_sum = the_sum + i

    end = time.time()

    return the_sum, end - start
    
for i in range(5):
    print("Sum is %d required %10.7f seconds" % sum_of_n_2(10000))
```

Résultat:  
`Sum is 50005000 required 0.0018950 seconds`  
`Sum is 50005000 required 0.0018620 seconds`  
`Sum is 50005000 required 0.0019171 seconds`  
`Sum is 50005000 required 0.0019162 seconds`  
`Sum is 50005000 required 0.0019360 seconds`

À cause la fonction, la vitesse d'execution est proportionnelle au chiffre mis en entré. 100 000 est ==10 fois plus long== à executer que 10 000.

Voici un code optimiser et son résultat:

```Python
import time

def sum_of_n_3(n):
    start = time.time()
    return (n * (n + 1)) / 2, time.time() - start



print("Sum is %d required %10.7f seconds" % sum_of_n_3(10000))
print("Sum is %d required %10.7f seconds" % sum_of_n_3(100000))
```

Résultat:  
`Sum is 50005000 required 0.00000095 seconds`  
`Sum is 5000050000 required 0.00000095 seconds`

Cette fonction n'est pas influencée par la valeur de `n`. C'est une bonne manière de tester l'efficacité ==*mais*== le résultat ***peut varier*** d'un ordinateur à l'autre. Il ce peut qu'un ordinateur plus vieux soit plus rapide avec la première méthode (**à cause de la division**).

### 2.2 Big *O* notation
Si nous prenons la première fonction créée, nous pouvons dire que:
$$
T(n) = 1+ n
$$
Où `T` est le temps que ça prend pour résoudre un problème de grosseur n.
Cette observation est valide car nous avons pu observer que n de 10 000 prends 10 fois moins de temps à éxecuter que un n de 100 000.

Il esy important de comprendre que nous voulons une approximation, le temps exaxct importe peu et le nombre d'execution encore moins. Ainsi, la constante de 1 peut être ignorer, elle affecte très peu le résultat final lorsque n est grand.

En notation ***O***, nous pourrions dire que la première fonction créer 


id: 2a1b92cbe586410faca655e24a20dcc1
parent_id: edf2f3c3590445b9802adf27c19151e0
created_time: 2025-01-06T19:53:46.927Z
updated_time: 2025-01-07T17:24:20.204Z
is_conflict: 0
latitude: 45.50168890
longitude: -73.56725600
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2025-01-06T19:53:46.927Z
user_updated_time: 2025-01-07T17:24:20.204Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
deleted_time: 0
type_: 1